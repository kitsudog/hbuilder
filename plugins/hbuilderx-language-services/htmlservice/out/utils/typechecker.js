"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getMembers=void 0;const core_1=require("../../../core");function getReturnType(e,t){if(e&&t){const r=e.getSignaturesOfType(t,0)[0];return e.getReturnTypeOfSignature(r)}}function getPropsType(e,t){if(e&&e.properties)return e.properties.map((e=>{if(e&&e.type&&e.type.properties){let r,o=e.type.properties.find((e=>"type"===e.escapedName));switch(o&&t.typeToString(t.getTypeOfSymbolAtLocation(o,o.valueDeclaration))){case"NumberConstructor":r=t.getNumberType();break;case"StringConstructor":r=t.getStringType();break;case"BooleanConstructor":r=t.getBooleanType();break;case"FunctionConstructor":r=o&&t.getTypeOfSymbol(o);break;default:r=o&&t.getAnyType()}e&&o&&(e.type=r)}})),e}function getComputedReturnType(e,t,r){if(t){const r=t.members;if(r){for(const t of r.values()){const r=e.getSignaturesOfType(t.type,0);if(r.length>0){const o=r[0],s=e.getReturnTypeOfSignature(o);t.flags=core_1.ts.SymbolFlags.Property,t.type.flags=s.flags}}t.members=r}}return t}function getMembers(e,t,r){if(e){let t,o,s,n,p;e.forEach((e=>{const i=core_1.ts.isPropertyAssignment(e)||core_1.ts.isMethodDeclaration(e)?e.name.getText():"";switch(i){case"methods":s=core_1.ts.isPropertyAssignment(e)&&r.getTypeAtLocation(e.initializer);break;case"data":if(i&&core_1.ts.isMethodDeclaration(e)){let o=r.getTypeAtLocation(e);t=getReturnType(r,o)}else if(e&&core_1.ts.isPropertyAssignment(e)){let o=r.getTypeAtLocation(e.initializer);t=o}break;case"setup":let a=r.getTypeAtLocation(e);p=getReturnType(r,a);break;case"props":n=r.getTypeAtLocation(e),getPropsType(n,r);break;case"computed":o=r.getTypeAtLocation(e),getComputedReturnType(r,o,core_1.ts)}}));return[t,o,s,n,p].reduce(((e,t)=>t&&t.members?new Map([...e,...t.members]):e),new Map)}}exports.getMembers=getMembers;