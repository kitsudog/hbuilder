"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getFoldingRanges=void 0;const cssScanner_1=require("../parser/cssScanner"),scssScanner_1=require("../parser/scssScanner"),lessScanner_1=require("../parser/lessScanner");function getFoldingRanges(e,n){return limitFoldingRanges(computeFoldingRanges(e),n)}function computeFoldingRanges(e){function n(n){return e.positionAt(n.offset).line}function t(n){return e.positionAt(n.offset+n.len).line}function s(e,s){const r=n(e),i=t(e);return r!==i?{startLine:r,endLine:i,kind:s}:null}const r=[],i=[],c=function(){switch(e.languageId){case"scss":return new scssScanner_1.SCSSScanner;case"less":return new lessScanner_1.LESSScanner;default:return new cssScanner_1.Scanner}}();c.ignoreComment=!1,c.setSource(e.getText());let a=c.scan(),o=null;for(;a.type!==cssScanner_1.TokenType.EOF;){switch(a.type){case cssScanner_1.TokenType.CurlyL:case scssScanner_1.InterpolationFunction:i.push({line:n(a),type:"brace",isStart:!0});break;case cssScanner_1.TokenType.CurlyR:if(0!==i.length){const e=popPrevStartDelimiterOfType(i,"brace");if(!e)break;let n=t(a);"brace"===e.type&&(o&&t(o)!==n&&n--,e.line!==n&&r.push({startLine:e.line,endLine:n,kind:void 0}))}break;case cssScanner_1.TokenType.Comment:{const c=e=>"#region"===e?{line:n(a),type:"comment",isStart:!0}:{line:t(a),type:"comment",isStart:!1},o=n=>{const t=n.text.match(/^\s*\/\*\s*(#region|#endregion)\b\s*(.*?)\s*\*\//);if(t)return c(t[1]);if("scss"===e.languageId||"less"===e.languageId){const e=n.text.match(/^\s*\/\/\s*(#region|#endregion)\b\s*(.*?)\s*/);if(e)return c(e[1])}return null},l=o(a);if(l)if(l.isStart)i.push(l);else{const e=popPrevStartDelimiterOfType(i,"comment");if(!e)break;"comment"===e.type&&e.line!==l.line&&r.push({startLine:e.line,endLine:l.line,kind:"region"})}else{const e=s(a,"comment");e&&r.push(e)}break}}o=a,a=c.scan()}return r}function popPrevStartDelimiterOfType(e,n){if(0===e.length)return null;for(let t=e.length-1;t>=0;t--)if(e[t].type===n&&e[t].isStart)return e.splice(t,1)[0];return null}function limitFoldingRanges(e,n){const t=n&&n.rangeLimit||Number.MAX_VALUE,s=e.sort(((e,n)=>{let t=e.startLine-n.startLine;return 0===t&&(t=e.endLine-n.endLine),t})),r=[];let i=-1;return s.forEach((e=>{e.startLine<i&&i<e.endLine||(r.push(e),i=e.endLine)})),r.length<t?r:r.slice(0,t)}exports.getFoldingRanges=getFoldingRanges;