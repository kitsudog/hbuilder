"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isInString=exports.getTypeName=exports.getTokenAtPosition=exports.getRelevantTokens=exports.getArgumentsSpecialStringType=void 0;const core_1=require("../../../core");function getArgumentsSpecialStringType(e,n,t){var o;let i=t.languageService.getSignatureHelpItems(e,n,void 0);if(i){let e=i.items;if(e.length>0){let n=e[0],t=i.argumentIndex;if((null==n?void 0:n.parameters)&&(null===(o=null==n?void 0:n.parameters)||void 0===o?void 0:o.length)>t){let e=n.parameters[t],o="";null==e||e.displayParts.forEach((e=>{o+=e.text}));let i=o.split(":");if(2===i.length){return i[1].split("|")}}}}return[]}function getTokenAtPosition(e,n){return getTokenAtPositionWorker(e,n,!0,void 0,!1)}function getTokenAtPositionWorker(e,n,t,o,i){let r=e;e:for(;;){for(const s of r.getChildren(e)){if((t?s.getFullStart():s.getStart(e,!0))>n)break;const l=s.getEnd();if(n<l||n===l&&(s.kind===core_1.ts.SyntaxKind.EndOfFileToken||i)){r=s;continue e}if(o&&l===n){const t=findPrecedingToken(n,e,s);if(t&&o(t))return t}}return r}}function isNonWhitespaceToken(e){return core_1.ts.isToken(e)}function some(e,n){if(e){if(!n)return e.length>0;for(const t of e)if(n(t))return!0}return!1}function binarySearchKey(e,n,t,o,i){if(!some(e))return-1;let r=i||0,s=e.length-1;for(;r<=s;){const i=r+(s-r>>1);switch(o(t(e[i],i),n)){case-1:r=i+1;break;case 0:return i;case 1:s=i-1}}return~r}function nodeHasTokens(e,n){return e.kind!==core_1.ts.SyntaxKind.EndOfFileToken&&0!==e.getWidth(n)}function findRightmostChildNodeWithTokens(e,n,t){for(let o=n-1;o>=0;o--){e[o];if(nodeHasTokens(e[o],t))return e[o]}}function findRightmostToken(e,n){if(isNonWhitespaceToken(e))return e;const t=e.getChildren(n);if(0===t.length)return e;const o=findRightmostChildNodeWithTokens(t,t.length,n);return o&&findRightmostToken(o,n)}function findPrecedingToken(e,n,t,o){const i=function t(i){if(isNonWhitespaceToken(i)&&i.kind!==core_1.ts.SyntaxKind.EndOfFileToken)return i;const r=i.getChildren(n),s=binarySearchKey(r,e,((e,n)=>n),((n,t)=>e<r[n].end?!r[n-1]||e>=r[n-1].end?0:1:-1));if(s>=0&&r[s]){const i=r[s];if(e<i.end){const l=i.getStart(n,!o);if(l>=e||!nodeHasTokens(i,n)){const e=findRightmostChildNodeWithTokens(r,s,n);return e&&findRightmostToken(e,n)}return t(i)}}const l=findRightmostChildNodeWithTokens(r,r.length,n);return l&&findRightmostToken(l,n)}(t||n);return i}function getRelevantTokens(e,n){console.log(`getRelevantTokens params: ${e}`);const t=findPrecedingToken(e,n);if(console.log(`previous token pos: ${null==t?void 0:t.pos}`),console.log(`previous token end: ${null==t?void 0:t.end}`),console.log(`previous token kind: ${null==t?void 0:t.kind}`),t&&e<=t.end&&(isMemberName(t)||isKeyword(t.kind))){console.log("getRelevatTokens enter if");const e=findPrecedingToken(t.getFullStart(),n,void 0);return console.log(`context token pos: ${null==e?void 0:e.pos}`),console.log(`context token end: ${null==e?void 0:e.end}`),{contextToken:e,previousToken:t}}return{contextToken:t,previousToken:t}}function isMemberName(e){return e.kind===core_1.ts.SyntaxKind.Identifier}function isKeyword(e){return core_1.ts.SyntaxKind.FirstKeyword<=e&&e<=core_1.ts.SyntaxKind.LastKeyword}function getTouchingPropertyName(e,n){return getTouchingToken(e,n,(e=>isPropertyNameLiteral(e)||isKeyword(e.kind)))}function getTouchingToken(e,n,t){return getTokenAtPositionWorker(e,n,!1,t,!1)}function isPropertyNameLiteral(e){switch(e.kind){case core_1.ts.SyntaxKind.Identifier:case core_1.ts.SyntaxKind.StringLiteral:case core_1.ts.SyntaxKind.NoSubstitutionTemplateLiteral:case core_1.ts.SyntaxKind.NumericLiteral:return!0;default:return!1}}function getLeftmostAccessExpression(e){for(;isAccessExpression(e);)e=e.expression;return e}function isAccessExpression(e){return e.kind===core_1.ts.SyntaxKind.PropertyAccessExpression||e.kind===core_1.ts.SyntaxKind.ElementAccessExpression}function nodeIsMissing(e){return void 0===e||e.pos===e.end&&e.pos>=0&&e.kind!==core_1.ts.SyntaxKind.EndOfFileToken}function isCallExpression(e){return e.kind===core_1.ts.SyntaxKind.CallExpression}function last(e){return e[e.length-1]}function isLiteralImportTypeNode(e){return core_1.ts.isImportTypeNode(e)&&core_1.ts.isLiteralTypeNode(e.argument)&&core_1.ts.isStringLiteral(e.argument.literal)}function isInRightSideOfInternalImportEqualsDeclaration(e){for(;e.parent.kind===core_1.ts.SyntaxKind.QualifiedName;)e=e.parent;return isInternalModuleImportEqualsDeclaration(e.parent)}function isInternalModuleImportEqualsDeclaration(e){return e.kind===core_1.ts.SyntaxKind.ImportEqualsDeclaration&&e.moduleReference.kind!==core_1.ts.SyntaxKind.ExternalModuleReference}function skipAlias(e,n){return e.flags&core_1.ts.SymbolFlags.Alias?n.getAliasedSymbol(e):e}function symbolCanBeReferencedAtTypeLocation(e,n,t=new Map){const o=e;return!!(o.flags&core_1.ts.SymbolFlags.Type)||n.isUnknownSymbol(o)||!!(o.flags&core_1.ts.SymbolFlags.Module)&&n.getExportsOfModule(o).some((e=>symbolCanBeReferencedAtTypeLocation(e,n,t)))}function isInString(e,n,t=findPrecedingToken(n,e)){if(t&&isStringTextContainingNode(t)){const o=t.getStart(e),i=t.getEnd();if(o<n&&n<i)return!0;if(n===i)return!!t.isUnterminated}return!1}function isStringTextContainingNode(e){return e.kind===core_1.ts.SyntaxKind.StringLiteral||isTemplateLiteralKind(e.kind)}function isTemplateLiteralKind(e){return core_1.ts.SyntaxKind.FirstTemplateToken<=e&&e<=core_1.ts.SyntaxKind.LastTemplateToken}function getTypeName(e,n,t){const o=getRelevantTokens(t,n);o.previousToken;let i=o.contextToken;console.log(`context token start:  ${null==i?void 0:i.pos}`),console.log(`context token end: ${null==i?void 0:i.end}`),console.log(`context token kind:  ${null==i?void 0:i.kind}`);const r=e.getTypeChecker();let s,l=getTokenAtPosition(n,t),a=l,c=!1,d=!1;if(i){let e=i.parent;if(console.log(`parent kind: ${e.kind}`),console.log(`parent pos: ${e.pos}`),console.log(`parent end: ${e.end}`),i.kind===core_1.ts.SyntaxKind.DotToken||i.kind===core_1.ts.SyntaxKind.QuestionDotToken)switch(console.log("contextToken kind dot"),c=i.kind===core_1.ts.SyntaxKind.DotToken,d=i.kind===core_1.ts.SyntaxKind.QuestionDotToken,console.log(`parent kind: ${e.kind}`),e.kind){case core_1.ts.SyntaxKind.PropertyAccessExpression:console.log(`parent pos: ${e.pos}`),console.log(`parent end: ${e.end}`),s=e,a=s.expression;const t=getLeftmostAccessExpression(s);if(console.log(`node kind: ${a.kind}`),nodeIsMissing(t)||(isCallExpression(a)||core_1.ts.isFunctionLike(a))&&a.end===i.pos&&a.getChildCount(n)&&last(a.getChildren(n)).kind!==core_1.ts.SyntaxKind.CloseParenToken)return;break;case core_1.ts.SyntaxKind.QualifiedName:a=e.left;break;case core_1.ts.SyntaxKind.ModuleDeclaration:a=e.name;break;case core_1.ts.SyntaxKind.ImportType:a=e;break;case core_1.ts.SyntaxKind.MetaProperty:a=e.getFirstToken(n);break;default:return}}let g=!1,u=[];(c||d)&&function(){var e,n;console.log("get typescript member symbol");const t=isLiteralImportTypeNode(a),o=t&&!a.isTypeOf,i=isInRightSideOfInternalImportEqualsDeclaration(a);if(core_1.ts.isEntityName(a)||t||core_1.ts.isPropertyAccessExpression(a)){console.log("entity name");const s=core_1.ts.isModuleDeclaration(a.parent);s&&(g=!0);let l=r.getSymbolAtLocation(a);if(console.log(`symbol node start: ${a.pos}`),console.log(`symbol node end: ${a.end}`),console.log(`symbol node kind: ${a.kind}`),console.log(`symbol node flags: ${a.flags}`),console.log(`symbol text: ${null==l?void 0:l.escapedName}`),l){console.log("enter symbol if"),console.log(`symbol flags: ${l.flags}`),console.log(`symbol declarations length: ${null===(e=l.declarations)||void 0===e?void 0:e.length}`);{console.log("enter symbol second if");const e=r.getExportsOfModule(l),c=e=>r.isValidPropertyAccess(t?a:a.parent,e.name),d=e=>symbolCanBeReferencedAtTypeLocation(e,r),g=s?e=>{var n;return!!(e.flags&core_1.ts.SymbolFlags.Namespace)&&!(null===(n=e.declarations)||void 0===n?void 0:n.every((e=>e.parent===a.parent)))}:i?e=>d(e)||c(e):o?d:c;for(const n of e)g(n)&&u.push(n);if(
//!isTypeLocation &&
l.declarations&&l.declarations.some((e=>e.kind!==core_1.ts.SyntaxKind.SourceFile&&e.kind!==core_1.ts.SyntaxKind.ModuleDeclaration&&e.kind!==core_1.ts.SyntaxKind.EnumDeclaration))){console.log("enter symbol third if");let e=r.getTypeOfSymbolAtLocation(l,a);e.getSymbol()&&console.log("type is: ",null===(n=e.getSymbol())||void 0===n?void 0:n.escapedName)}return}}}}()}exports.getArgumentsSpecialStringType=getArgumentsSpecialStringType,exports.getTokenAtPosition=getTokenAtPosition,exports.getRelevantTokens=getRelevantTokens,exports.isInString=isInString,exports.getTypeName=getTypeName;