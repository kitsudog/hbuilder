/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */


"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/tsserver/server.ts
var server_exports = {};
__export(server_exports, {
  CharacterCodes: () => CharacterCodes,
  Debug: () => Debug,
  JsTyping: () => JsTyping,
  LanguageServiceMode: () => LanguageServiceMode,
  LogLevel: () => LogLevel,
  assertType: () => assertType,
  combinePaths: () => combinePaths,
  createQueue: () => createQueue,
  directorySeparator: () => directorySeparator,
  getDirectoryPath: () => getDirectoryPath,
  getRootLength: () => getRootLength,
  noop: () => noop,
  noopFileWatcher: () => noopFileWatcher,
  normalizePath: () => normalizePath,
  normalizeSlashes: () => normalizeSlashes,
  perfLogger: () => perfLogger,
  server: () => ts_server_exports,
  setStackTraceLimit: () => setStackTraceLimit2,
  startTracing: () => startTracing,
  stripQuotes: () => stripQuotes,
  sys: () => sys,
  toFileNameLowerCase: () => toFileNameLowerCase,
  tracing: () => tracing,
  validateLocaleAndSetLanguage: () => validateLocaleAndSetLanguage,
  version: () => version2,
  versionMajorMinor: () => versionMajorMinor
});
module.exports = __toCommonJS(server_exports);

// src/tsserver/_namespaces/ts.ts
var ts = __toESM(require("typescript/lib/tsserverlibrary"));

// src/tsserver/_namespaces/ts.server.ts
var ts_server_exports = {};
__export(ts_server_exports, {
  ActionInvalidate: () => ActionInvalidate,
  ActionPackageInstalled: () => ActionPackageInstalled,
  ActionSet: () => ActionSet,
  ActionWatchTypingLocations: () => ActionWatchTypingLocations,
  Arguments: () => Arguments,
  EventBeginInstallTypes: () => EventBeginInstallTypes,
  EventEndInstallTypes: () => EventEndInstallTypes,
  EventInitializationFailed: () => EventInitializationFailed,
  EventTypesRegistry: () => EventTypesRegistry,
  LogLevel: () => LogLevel2,
  Logger: () => Logger3,
  Msg: () => Msg,
  Project: () => Project2,
  ProjectService: () => ProjectService2,
  ServerCancellationToken: () => ServerCancellationToken3,
  Session: () => Session,
  createInstallTypingsRequest: () => createInstallTypingsRequest,
  emptyArray: () => emptyArray,
  findArgument: () => findArgument,
  formatMessage: () => formatMessage,
  getLogLevel: () => getLogLevel,
  hasArgument: () => hasArgument,
  indent: () => indent,
  initializeNodeSystem: () => initializeNodeSystem,
  nowString: () => nowString,
  nullCancellationToken: () => nullCancellationToken,
  nullTypingsInstaller: () => nullTypingsInstaller,
  stringifyIndented: () => stringifyIndented,
  toEvent: () => toEvent
});
var _ts = __toESM(require("typescript/lib/tsserverlibrary"));

// src/tsserver/nodeServer.ts
function parseLoggingEnvironmentString(logEnvStr) {
  if (!logEnvStr) {
    return {};
  }
  const logEnv = { logToFile: true };
  const args = logEnvStr.split(" ");
  const len = args.length - 1;
  for (let i = 0; i < len; i += 2) {
    const option = args[i];
    const { value, extraPartCounter } = getEntireValue(i + 1);
    i += extraPartCounter;
    if (option && value) {
      switch (option) {
        case "-file":
          logEnv.file = value;
          break;
        case "-level":
          const level = getLogLevel(value);
          logEnv.detailLevel = level !== void 0 ? level : LogLevel2.normal;
          break;
        case "-traceToConsole":
          logEnv.traceToConsole = value.toLowerCase() === "true";
          break;
        case "-logToFile":
          logEnv.logToFile = value.toLowerCase() === "true";
          break;
      }
    }
  }
  return logEnv;
  function getEntireValue(initialIndex) {
    let pathStart = args[initialIndex];
    let extraPartCounter = 0;
    if (pathStart.charCodeAt(0) === CharacterCodes.doubleQuote && pathStart.charCodeAt(pathStart.length - 1) !== CharacterCodes.doubleQuote) {
      for (let i = initialIndex + 1; i < args.length; i++) {
        pathStart += " ";
        pathStart += args[i];
        extraPartCounter++;
        if (pathStart.charCodeAt(pathStart.length - 1) === CharacterCodes.doubleQuote)
          break;
      }
    }
    return { value: stripQuotes(pathStart), extraPartCounter };
  }
}
function parseServerMode() {
  const mode = findArgument("--serverMode");
  if (!mode)
    return void 0;
  switch (mode.toLowerCase()) {
    case "semantic":
      return LanguageServiceMode.Semantic;
    case "partialsemantic":
      return LanguageServiceMode.PartialSemantic;
    case "syntactic":
      return LanguageServiceMode.Syntactic;
    default:
      return mode;
  }
}
function initializeNodeSystem() {
  const sys3 = Debug.checkDefined(sys);
  const childProcess = require("child_process");
  const fs = require("fs");
  class Logger4 {
    constructor(logFilename, traceToConsole, level) {
      this.logFilename = logFilename;
      this.traceToConsole = traceToConsole;
      this.level = level;
      this.seq = 0;
      this.inGroup = false;
      this.firstInGroup = true;
      this.fd = -1;
      if (this.logFilename) {
        try {
          this.fd = fs.openSync(this.logFilename, "w");
        } catch (_) {
        }
      }
    }
    static padStringRight(str, padding) {
      return (str + padding).slice(0, padding.length);
    }
    close() {
      if (this.fd >= 0) {
        fs.close(this.fd, noop);
      }
    }
    getLogFileName() {
      return this.logFilename;
    }
    perftrc(s) {
      this.msg(s, Msg.Perf);
    }
    info(s) {
      this.msg(s, Msg.Info);
    }
    err(s) {
      this.msg(s, Msg.Err);
    }
    startGroup() {
      this.inGroup = true;
      this.firstInGroup = true;
    }
    endGroup() {
      this.inGroup = false;
    }
    loggingEnabled() {
      return !!this.logFilename || this.traceToConsole;
    }
    hasLevel(level) {
      return this.loggingEnabled() && this.level >= level;
    }
    msg(s, type = Msg.Err) {
      var _a, _b, _c;
      switch (type) {
        case Msg.Info:
          (_a = perfLogger) == null ? void 0 : _a.logInfoEvent(s);
          break;
        case Msg.Perf:
          (_b = perfLogger) == null ? void 0 : _b.logPerfEvent(s);
          break;
        default:
          (_c = perfLogger) == null ? void 0 : _c.logErrEvent(s);
          break;
      }
      if (!this.canWrite())
        return;
      s = `[${nowString()}] ${s}
`;
      if (!this.inGroup || this.firstInGroup) {
        const prefix = Logger4.padStringRight(type + " " + this.seq.toString(), "          ");
        s = prefix + s;
      }
      this.write(s, type);
      if (!this.inGroup) {
        this.seq++;
      }
    }
    canWrite() {
      return this.fd >= 0 || this.traceToConsole;
    }
    write(s, _type) {
      if (this.fd >= 0) {
        const buf = sys3.bufferFrom(s);
        fs.writeSync(
          this.fd,
          buf,
          0,
          buf.length,
          /*position*/
          null
        );
      }
      if (this.traceToConsole) {
        console.warn(s);
      }
    }
  }
  const libDirectory = getDirectoryPath(normalizePath(sys3.getExecutingFilePath()));
  const useWatchGuard = process.platform === "win32";
  const originalWatchDirectory = sys3.watchDirectory.bind(sys3);
  const logger = createLogger();
  Debug.loggingHost = {
    log(level, s) {
      switch (level) {
        case LogLevel.Error:
        case LogLevel.Warning:
          return logger.msg(s, Msg.Err);
        case LogLevel.Info:
        case LogLevel.Verbose:
          return logger.msg(s, Msg.Info);
      }
    }
  };
  const pending = createQueue();
  let canWrite = true;
  if (useWatchGuard) {
    const currentDrive = extractWatchDirectoryCacheKey(
      sys3.resolvePath(sys3.getCurrentDirectory()),
      /*currentDriveKey*/
      void 0
    );
    const statusCache = /* @__PURE__ */ new Map();
    sys3.watchDirectory = (path, callback, recursive, options) => {
      const cacheKey = extractWatchDirectoryCacheKey(path, currentDrive);
      let status = cacheKey && statusCache.get(cacheKey);
      if (status === void 0) {
        if (logger.hasLevel(LogLevel2.verbose)) {
          logger.info(`${cacheKey} for path ${path} not found in cache...`);
        }
        try {
          const args = [combinePaths(libDirectory, "watchGuard.js"), path];
          if (logger.hasLevel(LogLevel2.verbose)) {
            logger.info(`Starting ${process.execPath} with args:${stringifyIndented(args)}`);
          }
          childProcess.execFileSync(process.execPath, args, { stdio: "ignore", env: { ELECTRON_RUN_AS_NODE: "1" } });
          status = true;
          if (logger.hasLevel(LogLevel2.verbose)) {
            logger.info(`WatchGuard for path ${path} returned: OK`);
          }
        } catch (e) {
          status = false;
          if (logger.hasLevel(LogLevel2.verbose)) {
            logger.info(`WatchGuard for path ${path} returned: ${e.message}`);
          }
        }
        if (cacheKey) {
          statusCache.set(cacheKey, status);
        }
      } else if (logger.hasLevel(LogLevel2.verbose)) {
        logger.info(`watchDirectory for ${path} uses cached drive information.`);
      }
      if (status) {
        return watchDirectorySwallowingException(path, callback, recursive, options);
      } else {
        return noopFileWatcher;
      }
    };
  } else {
    sys3.watchDirectory = watchDirectorySwallowingException;
  }
  sys3.write = (s) => writeMessage(sys3.bufferFrom(s, "utf8"));
  sys3.setTimeout = setTimeout;
  sys3.clearTimeout = clearTimeout;
  sys3.setImmediate = setImmediate;
  sys3.clearImmediate = clearImmediate;
  if (typeof global !== "undefined" && global.gc) {
    sys3.gc = () => {
      var _a;
      return (_a = global.gc) == null ? void 0 : _a.call(global);
    };
  }
  let cancellationToken;
  try {
    const factory = require("./cancellationToken");
    cancellationToken = factory(sys3.args);
  } catch (e) {
    cancellationToken = nullCancellationToken;
  }
  const localeStr = findArgument("--locale");
  if (localeStr) {
    validateLocaleAndSetLanguage(localeStr, sys3);
  }
  const modeOrUnknown = parseServerMode();
  let serverMode;
  let unknownServerMode;
  if (modeOrUnknown !== void 0) {
    if (typeof modeOrUnknown === "number")
      serverMode = modeOrUnknown;
    else
      unknownServerMode = modeOrUnknown;
  }
  return {
    args: process.argv,
    logger,
    cancellationToken,
    serverMode,
    unknownServerMode,
    startSession: startNodeSession
  };
  function createLogger() {
    const cmdLineLogFileName = findArgument("--logFile");
    const cmdLineVerbosity = getLogLevel(findArgument("--logVerbosity"));
    const envLogOptions = parseLoggingEnvironmentString(process.env.TSS_LOG);
    const unsubstitutedLogFileName = cmdLineLogFileName ? stripQuotes(cmdLineLogFileName) : envLogOptions.logToFile ? envLogOptions.file || libDirectory + "/.log" + process.pid.toString() : void 0;
    const substitutedLogFileName = unsubstitutedLogFileName ? unsubstitutedLogFileName.replace("PID", process.pid.toString()) : void 0;
    const logVerbosity = cmdLineVerbosity || envLogOptions.detailLevel;
    return new Logger4(substitutedLogFileName, envLogOptions.traceToConsole, logVerbosity);
  }
  function writeMessage(buf) {
    if (!canWrite) {
      pending.enqueue(buf);
    } else {
      canWrite = false;
      process.stdout.write(buf, setCanWriteFlagAndWriteMessageIfNecessary);
    }
  }
  function setCanWriteFlagAndWriteMessageIfNecessary() {
    canWrite = true;
    if (!pending.isEmpty()) {
      writeMessage(pending.dequeue());
    }
  }
  function extractWatchDirectoryCacheKey(path, currentDriveKey) {
    path = normalizeSlashes(path);
    if (isUNCPath(path)) {
      const firstSlash = path.indexOf(directorySeparator, 2);
      return firstSlash !== -1 ? toFileNameLowerCase(path.substring(0, firstSlash)) : path;
    }
    const rootLength = getRootLength(path);
    if (rootLength === 0) {
      return currentDriveKey;
    }
    if (path.charCodeAt(1) === CharacterCodes.colon && path.charCodeAt(2) === CharacterCodes.slash) {
      return toFileNameLowerCase(path.charAt(0));
    }
    if (path.charCodeAt(0) === CharacterCodes.slash && path.charCodeAt(1) !== CharacterCodes.slash) {
      return currentDriveKey;
    }
    return void 0;
  }
  function isUNCPath(s) {
    return s.length > 2 && s.charCodeAt(0) === CharacterCodes.slash && s.charCodeAt(1) === CharacterCodes.slash;
  }
  function watchDirectorySwallowingException(path, callback, recursive, options) {
    try {
      return originalWatchDirectory(path, callback, recursive, options);
    } catch (e) {
      logger.info(`Exception when creating directory watcher: ${e.message}`);
      return noopFileWatcher;
    }
  }
}
function parseEventPort(eventPortStr) {
  const eventPort = eventPortStr === void 0 ? void 0 : parseInt(eventPortStr);
  return eventPort !== void 0 && !isNaN(eventPort) ? eventPort : void 0;
}
function startNodeSession(options, logger, cancellationToken) {
  const childProcess = require("child_process");
  const os = require("os");
  const net = require("net");
  const readline = require("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false
  });
  const _NodeTypingsInstaller = class _NodeTypingsInstaller {
    constructor(telemetryEnabled2, logger2, host, globalTypingsCacheLocation, typingSafeListLocation2, typesMapLocation2, npmLocation2, validateDefaultNpmLocation2, event) {
      this.telemetryEnabled = telemetryEnabled2;
      this.logger = logger2;
      this.host = host;
      this.globalTypingsCacheLocation = globalTypingsCacheLocation;
      this.typingSafeListLocation = typingSafeListLocation2;
      this.typesMapLocation = typesMapLocation2;
      this.npmLocation = npmLocation2;
      this.validateDefaultNpmLocation = validateDefaultNpmLocation2;
      this.event = event;
      this.activeRequestCount = 0;
      this.requestQueue = createQueue();
      this.requestMap = /* @__PURE__ */ new Map();
      // Maps operation ID to newest requestQueue entry with that ID
      /** We will lazily request the types registry on the first call to `isKnownTypesPackageName` and store it in `typesRegistryCache`. */
      this.requestedRegistry = false;
    }
    isKnownTypesPackageName(name) {
      const validationResult = JsTyping.validatePackageName(name);
      if (validationResult !== JsTyping.NameValidationResult.Ok) {
        return false;
      }
      if (this.requestedRegistry) {
        return !!this.typesRegistryCache && this.typesRegistryCache.has(name);
      }
      this.requestedRegistry = true;
      this.send({ kind: "typesRegistry" });
      return false;
    }
    installPackage(options2) {
      this.send({ kind: "installPackage", ...options2 });
      Debug.assert(this.packageInstalledPromise === void 0);
      return new Promise((resolve, reject) => {
        this.packageInstalledPromise = { resolve, reject };
      });
    }
    attach(projectService) {
      this.projectService = projectService;
      if (this.logger.hasLevel(LogLevel2.requestTime)) {
        this.logger.info("Binding...");
      }
      const args = [Arguments.GlobalCacheLocation, this.globalTypingsCacheLocation];
      if (this.telemetryEnabled) {
        args.push(Arguments.EnableTelemetry);
      }
      if (this.logger.loggingEnabled() && this.logger.getLogFileName()) {
        args.push(Arguments.LogFile, combinePaths(getDirectoryPath(normalizeSlashes(this.logger.getLogFileName())), `ti-${process.pid}.log`));
      }
      if (this.typingSafeListLocation) {
        args.push(Arguments.TypingSafeListLocation, this.typingSafeListLocation);
      }
      if (this.typesMapLocation) {
        args.push(Arguments.TypesMapLocation, this.typesMapLocation);
      }
      if (this.npmLocation) {
        args.push(Arguments.NpmLocation, this.npmLocation);
      }
      if (this.validateDefaultNpmLocation) {
        args.push(Arguments.ValidateDefaultNpmLocation);
      }
      const execArgv = [];
      for (const arg of process.execArgv) {
        const match = /^--((?:debug|inspect)(?:-brk)?)(?:=(\d+))?$/.exec(arg);
        if (match) {
          const currentPort = match[2] !== void 0 ? +match[2] : match[1].charAt(0) === "d" ? 5858 : 9229;
          execArgv.push(`--${match[1]}=${currentPort + 1}`);
          break;
        }
      }
      const typingsInstaller = combinePaths(getDirectoryPath(sys.getExecutingFilePath()), "typingsInstaller.js");
      this.installer = childProcess.fork(typingsInstaller, args, { execArgv });
      this.installer.on("message", (m) => this.handleMessage(m));
      this.host.setImmediate(() => this.event({ pid: this.installer.pid }, "typingsInstallerPid"));
      process.on("exit", () => {
        this.installer.kill();
      });
    }
    onProjectClosed(p) {
      this.send({ projectName: p.getProjectName(), kind: "closeProject" });
    }
    send(rq) {
      this.installer.send(rq);
    }
    enqueueInstallTypingsRequest(project, typeAcquisition, unresolvedImports) {
      const request = createInstallTypingsRequest(project, typeAcquisition, unresolvedImports);
      if (this.logger.hasLevel(LogLevel2.verbose)) {
        if (this.logger.hasLevel(LogLevel2.verbose)) {
          this.logger.info(`Scheduling throttled operation:${stringifyIndented(request)}`);
        }
      }
      const operationId = project.getProjectName();
      const operation = () => {
        if (this.logger.hasLevel(LogLevel2.verbose)) {
          this.logger.info(`Sending request:${stringifyIndented(request)}`);
        }
        this.send(request);
      };
      const queuedRequest = { operationId, operation };
      if (this.activeRequestCount < _NodeTypingsInstaller.maxActiveRequestCount) {
        this.scheduleRequest(queuedRequest);
      } else {
        if (this.logger.hasLevel(LogLevel2.verbose)) {
          this.logger.info(`Deferring request for: ${operationId}`);
        }
        this.requestQueue.enqueue(queuedRequest);
        this.requestMap.set(operationId, queuedRequest);
      }
    }
    handleMessage(response) {
      if (this.logger.hasLevel(LogLevel2.verbose)) {
        this.logger.info(`Received response:${stringifyIndented(response)}`);
      }
      switch (response.kind) {
        case EventTypesRegistry:
          this.typesRegistryCache = new Map(Object.entries(response.typesRegistry));
          break;
        case ActionPackageInstalled: {
          const { success, message } = response;
          if (success) {
            this.packageInstalledPromise.resolve({ successMessage: message });
          } else {
            this.packageInstalledPromise.reject(message);
          }
          this.packageInstalledPromise = void 0;
          this.projectService.updateTypingsForProject(response);
          this.event(response, "setTypings");
          break;
        }
        case EventInitializationFailed: {
          const body = {
            message: response.message
          };
          const eventName = "typesInstallerInitializationFailed";
          this.event(body, eventName);
          break;
        }
        case EventBeginInstallTypes: {
          const body = {
            eventId: response.eventId,
            packages: response.packagesToInstall
          };
          const eventName = "beginInstallTypes";
          this.event(body, eventName);
          break;
        }
        case EventEndInstallTypes: {
          if (this.telemetryEnabled) {
            const body2 = {
              telemetryEventName: "typingsInstalled",
              payload: {
                installedPackages: response.packagesToInstall.join(","),
                installSuccess: response.installSuccess,
                typingsInstallerVersion: response.typingsInstallerVersion
              }
            };
            const eventName2 = "telemetry";
            this.event(body2, eventName2);
          }
          const body = {
            eventId: response.eventId,
            packages: response.packagesToInstall,
            success: response.installSuccess
          };
          const eventName = "endInstallTypes";
          this.event(body, eventName);
          break;
        }
        case ActionInvalidate: {
          this.projectService.updateTypingsForProject(response);
          break;
        }
        case ActionSet: {
          if (this.activeRequestCount > 0) {
            this.activeRequestCount--;
          } else {
            Debug.fail("Received too many responses");
          }
          while (!this.requestQueue.isEmpty()) {
            const queuedRequest = this.requestQueue.dequeue();
            if (this.requestMap.get(queuedRequest.operationId) === queuedRequest) {
              this.requestMap.delete(queuedRequest.operationId);
              this.scheduleRequest(queuedRequest);
              break;
            }
            if (this.logger.hasLevel(LogLevel2.verbose)) {
              this.logger.info(`Skipping defunct request for: ${queuedRequest.operationId}`);
            }
          }
          this.projectService.updateTypingsForProject(response);
          this.event(response, "setTypings");
          break;
        }
        case ActionWatchTypingLocations:
          this.projectService.watchTypingLocations(response);
          break;
        default:
          assertType(response);
      }
    }
    scheduleRequest(request) {
      if (this.logger.hasLevel(LogLevel2.verbose)) {
        this.logger.info(`Scheduling request for: ${request.operationId}`);
      }
      this.activeRequestCount++;
      this.host.setTimeout(request.operation, _NodeTypingsInstaller.requestDelayMillis);
    }
  };
  // This number is essentially arbitrary.  Processing more than one typings request
  // at a time makes sense, but having too many in the pipe results in a hang
  // (see https://github.com/nodejs/node/issues/7657).
  // It would be preferable to base our limit on the amount of space left in the
  // buffer, but we have yet to find a way to retrieve that value.
  _NodeTypingsInstaller.maxActiveRequestCount = 10;
  _NodeTypingsInstaller.requestDelayMillis = 100;
  let NodeTypingsInstaller = _NodeTypingsInstaller;
  class IOSession extends Session {
    constructor() {
      const event = (body, eventName) => {
        this.event(body, eventName);
      };
      const host = sys;
      const typingsInstaller = disableAutomaticTypingAcquisition ? void 0 : new NodeTypingsInstaller(telemetryEnabled, logger, host, getGlobalTypingsCacheLocation(), typingSafeListLocation, typesMapLocation, npmLocation, validateDefaultNpmLocation, event);
      super({
        host,
        cancellationToken,
        ...options,
        typingsInstaller: typingsInstaller || nullTypingsInstaller,
        byteLength: Buffer.byteLength,
        hrtime: process.hrtime,
        logger,
        canUseEvents: true,
        typesMapLocation
      });
      this.eventPort = eventPort;
      if (this.canUseEvents && this.eventPort) {
        const s = net.connect({ port: this.eventPort }, () => {
          this.eventSocket = s;
          if (this.socketEventQueue) {
            for (const event2 of this.socketEventQueue) {
              this.writeToEventSocket(event2.body, event2.eventName);
            }
            this.socketEventQueue = void 0;
          }
        });
      }
      this.constructed = true;
      this.requestQueue = [];
      this.requestRunning = false;
    }
    event(body, eventName) {
      Debug.assert(!!this.constructed, "Should only call `IOSession.prototype.event` on an initialized IOSession");
      if (this.canUseEvents && this.eventPort) {
        if (!this.eventSocket) {
          if (this.logger.hasLevel(LogLevel2.verbose)) {
            this.logger.info(`eventPort: event "${eventName}" queued, but socket not yet initialized`);
          }
          (this.socketEventQueue || (this.socketEventQueue = [])).push({ body, eventName });
          return;
        } else {
          Debug.assert(this.socketEventQueue === void 0);
          this.writeToEventSocket(body, eventName);
        }
      } else {
        super.event(body, eventName);
      }
    }
    writeToEventSocket(body, eventName) {
      this.eventSocket.write(formatMessage(toEvent(eventName, body), this.logger, this.byteLength, this.host.newLine), "utf8");
    }
    exit() {
      var _a;
      this.logger.info("Exiting...");
      this.projectService.closeLog();
      (_a = tracing) == null ? void 0 : _a.stopTracing();
      process.exit(0);
    }
    listen() {
      rl.on("line", (input) => {
        const message = input.trim();
        this.onMessage(message);
      });
      rl.on("close", () => {
        this.exit();
      });
    }
    async addMessage(msg) {
      this.requestQueue.push(msg);
      await this.consumeMessage();
    }
    async consumeMessage() {
      if (this.requestRunning) {
        return;
      }
      if (this.requestQueue.length === 0) {
        return;
      }
      const msg = this.requestQueue.shift();
      try {
        this.requestRunning = true;
        await super.onMessage(msg);
      } finally {
        this.requestRunning = false;
        this.consumeMessage();
      }
    }
    async onMessage(message) {
      this.addMessage(message);
    }
  }
  class IpcIOSession extends IOSession {
    writeMessage(msg) {
      const verboseLogging = logger.hasLevel(LogLevel2.verbose);
      if (verboseLogging) {
        const json = JSON.stringify(msg);
        logger.info(`${msg.type}:${indent(json)}`);
      }
      process.send(msg);
    }
    parseMessage(message) {
      return message;
    }
    toStringMessage(message) {
      return JSON.stringify(message, void 0, 2);
    }
    listen() {
      process.on("message", (e) => {
        this.onMessage(e);
      });
      process.on("disconnect", () => {
        this.exit();
      });
    }
  }
  const eventPort = parseEventPort(findArgument("--eventPort"));
  const typingSafeListLocation = findArgument(Arguments.TypingSafeListLocation);
  const typesMapLocation = findArgument(Arguments.TypesMapLocation) || combinePaths(getDirectoryPath(sys.getExecutingFilePath()), "typesMap.json");
  const npmLocation = findArgument(Arguments.NpmLocation);
  const validateDefaultNpmLocation = hasArgument(Arguments.ValidateDefaultNpmLocation);
  const disableAutomaticTypingAcquisition = hasArgument("--disableAutomaticTypingAcquisition");
  const useNodeIpc = hasArgument("--useNodeIpc");
  const telemetryEnabled = hasArgument(Arguments.EnableTelemetry);
  const commandLineTraceDir = findArgument("--traceDirectory");
  const traceDir = commandLineTraceDir ? stripQuotes(commandLineTraceDir) : process.env.TSS_TRACE;
  if (traceDir) {
    startTracing("server", traceDir);
  }
  const ioSession = useNodeIpc ? new IpcIOSession() : new IOSession();
  process.on("uncaughtException", (err) => {
    ioSession.logError(err, "unknown");
  });
  process.noAsar = true;
  ioSession.listen();
  function getGlobalTypingsCacheLocation() {
    switch (process.platform) {
      case "win32": {
        const basePath = process.env.LOCALAPPDATA || process.env.APPDATA || os.homedir && os.homedir() || process.env.USERPROFILE || process.env.HOMEDRIVE && process.env.HOMEPATH && normalizeSlashes(process.env.HOMEDRIVE + process.env.HOMEPATH) || os.tmpdir();
        return combinePaths(combinePaths(normalizeSlashes(basePath), "Microsoft/TypeScript"), versionMajorMinor);
      }
      case "openbsd":
      case "freebsd":
      case "netbsd":
      case "darwin":
      case "linux":
      case "android": {
        const cacheLocation = getNonWindowsCacheLocation(process.platform === "darwin");
        return combinePaths(combinePaths(cacheLocation, "typescript"), versionMajorMinor);
      }
      default:
        return Debug.fail(`unsupported platform '${process.platform}'`);
    }
  }
  function getNonWindowsCacheLocation(platformIsDarwin) {
    if (process.env.XDG_CACHE_HOME) {
      return process.env.XDG_CACHE_HOME;
    }
    const usersDir = platformIsDarwin ? "Users" : "home";
    const homePath = os.homedir && os.homedir() || process.env.HOME || (process.env.LOGNAME || process.env.USER) && `/${usersDir}/${process.env.LOGNAME || process.env.USER}` || os.tmpdir();
    const cacheFolder = platformIsDarwin ? "Library/Caches" : ".cache";
    return combinePaths(normalizeSlashes(homePath), cacheFolder);
  }
}

// src/tsserver/common.ts
function getLogLevel(level) {
  if (level) {
    const l = level.toLowerCase();
    for (const name in LogLevel2) {
      if (isNaN(+name) && l === name.toLowerCase()) {
        return LogLevel2[name];
      }
    }
  }
  return void 0;
}

// src/tsserver/_namespaces/ts.server.ts
var LogLevel2 = _ts.server.LogLevel;
var Msg = _ts.server.Msg;
var emptyArray = _ts.server.emptyArray;
var Arguments = _ts.server.Arguments;
var createInstallTypingsRequest = _ts.server.createInstallTypingsRequest;
var findArgument = _ts.server.findArgument;
var formatMessage = _ts.server.formatMessage;
var hasArgument = _ts.server.hasArgument;
var indent = _ts.server.indent;
var Logger3 = _ts.server.Logger;
var nowString = _ts.server.nowString;
var nullCancellationToken = _ts.server.nullCancellationToken;
var nullTypingsInstaller = _ts.server.nullTypingsInstaller;
var Project2 = _ts.server.Project;
var ProjectService2 = _ts.server.ProjectService;
var ServerCancellationToken3 = _ts.server.ServerCancellationToken;
var Session = _ts.server.Session;
var stringifyIndented = _ts.server.stringifyIndented;
var toEvent = _ts.server.toEvent;
var ActionSet = "action::set";
var ActionInvalidate = "action::invalidate";
var ActionPackageInstalled = "action::packageInstalled";
var EventTypesRegistry = "event::typesRegistry";
var EventBeginInstallTypes = "event::beginInstallTypes";
var EventEndInstallTypes = "event::endInstallTypes";
var EventInitializationFailed = "event::initializationFailed";
var ActionWatchTypingLocations = "action::watchTypingLocations";

// src/tsserver/_namespaces/ts.ts
var LanguageServiceMode = ts.LanguageServiceMode;
var sys = ts.sys;
var Debug = ts.Debug;
var setStackTraceLimit2 = ts.setStackTraceLimit;
var version2 = ts.version;
var noop = ts.noop;
var assertType = ts.assertType;
var CharacterCodes = ts.CharacterCodes;
var combinePaths = ts.combinePaths;
var createQueue = ts.createQueue;
var directorySeparator = ts.directorySeparator;
var getDirectoryPath = ts.getDirectoryPath;
var getRootLength = ts.getRootLength;
var JsTyping = ts.JsTyping;
var noopFileWatcher = ts.noopFileWatcher;
var normalizePath = ts.normalizePath;
var normalizeSlashes = ts.normalizeSlashes;
var perfLogger = ts.perfLogger;
var startTracing = ts.startTracing;
var stripQuotes = ts.stripQuotes;
var toFileNameLowerCase = ts.toFileNameLowerCase;
var tracing = ts.tracing;
var validateLocaleAndSetLanguage = ts.validateLocaleAndSetLanguage;
var versionMajorMinor = ts.versionMajorMinor;
var LogLevel = ts.LogLevel;

// src/tsserver/server.ts
function findArgumentStringArray(argName) {
  const arg = findArgument(argName);
  if (arg === void 0) {
    return emptyArray;
  }
  return arg.split(",").filter((name) => name !== "");
}
process.on("uncaughtException", () => {
});
process.on("unhandledRejection", () => {
});
function start({ args, logger, cancellationToken, serverMode, unknownServerMode, startSession: startServer }, platform) {
  logger.info(`Starting TS Server`);
  logger.info(`Version: ${version2}`);
  logger.info(`Arguments: ${args.join(" ")}`);
  logger.info(`Platform: ${platform} NodeVersion: ${process.version} CaseSensitive: ${sys.useCaseSensitiveFileNames}`);
  logger.info(`ServerMode: ${serverMode} hasUnknownServerMode: ${unknownServerMode}`);
  setStackTraceLimit2();
  if (Debug.isDebugging) {
    Debug.enableDebugInfo();
  }
  if (sys.tryEnableSourceMapsForHost && /^development$/i.test(sys.getEnvironmentVariable("NODE_ENV"))) {
    sys.tryEnableSourceMapsForHost();
  }
  console.log = (...args2) => logger.msg(args2.length === 1 ? args2[0] : args2.join(", "), Msg.Info);
  console.warn = (...args2) => logger.msg(args2.length === 1 ? args2[0] : args2.join(", "), Msg.Err);
  console.error = (...args2) => logger.msg(args2.length === 1 ? args2[0] : args2.join(", "), Msg.Err);
  startServer(
    {
      globalPlugins: findArgumentStringArray("--globalPlugins"),
      pluginProbeLocations: findArgumentStringArray("--pluginProbeLocations"),
      allowLocalPluginLoads: hasArgument("--allowLocalPluginLoads"),
      useSingleInferredProject: hasArgument("--useSingleInferredProject"),
      useInferredProjectPerProjectRoot: hasArgument("--useInferredProjectPerProjectRoot"),
      suppressDiagnosticEvents: hasArgument("--suppressDiagnosticEvents"),
      noGetErrOnBackgroundUpdate: hasArgument("--noGetErrOnBackgroundUpdate"),
      serverMode
    },
    logger,
    cancellationToken
  );
}
setStackTraceLimit2();
start(initializeNodeSystem(), require("os").platform());
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CharacterCodes,
  Debug,
  JsTyping,
  LanguageServiceMode,
  LogLevel,
  assertType,
  combinePaths,
  createQueue,
  directorySeparator,
  getDirectoryPath,
  getRootLength,
  noop,
  noopFileWatcher,
  normalizePath,
  normalizeSlashes,
  perfLogger,
  server,
  setStackTraceLimit,
  startTracing,
  stripQuotes,
  sys,
  toFileNameLowerCase,
  tracing,
  validateLocaleAndSetLanguage,
  version,
  versionMajorMinor
});
//# sourceMappingURL=tsserver.js.map
