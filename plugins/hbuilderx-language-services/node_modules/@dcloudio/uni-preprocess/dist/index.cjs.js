'use strict';

var MagicString = require('magic-string');
var xregexp = require('xregexp');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var MagicString__default = /*#__PURE__*/_interopDefault(MagicString);

function preprocess(source, options) {
    let isInPreprocessor = (_offset) => false;
    if (!source.includes('#endif')) {
        return {
            code: source,
            map: options.sourceMap
                ? new MagicString__default.default(source).generateMap(options.sourceMap)
                : null,
            isInPreprocessor,
        };
    }
    const context = options.context || {};
    const s = new MagicString__default.default(source);
    // [[start,end]]
    const ranges = [];
    isInPreprocessor = (offset) => {
        for (let i = 0; i < ranges.length; i++) {
            const range = ranges[i];
            if (range[0] <= offset && offset < range[1]) {
                return true;
            }
        }
        return false;
    };
    function preprocessByType(type) {
        replaceRecursive(type, source, s, (s, startMatches, endMatches, include, recurse) => {
            // I need to recurse first, so I don't catch "inner" else-directives
            recurse(include.value, include.start);
            const variant = startMatches.value[1];
            const test = (startMatches.value[2] || '').trim();
            switch (variant) {
                case 'ifdef':
                    if (testPasses(test, context)) {
                        s.remove(startMatches.start, startMatches.end);
                        s.remove(endMatches.start, endMatches.end);
                    }
                    else {
                        s.remove(startMatches.start, endMatches.end);
                    }
                    ranges.push([startMatches.start, endMatches.end]);
                    return;
                case 'ifndef':
                    if (!testPasses(test, context)) {
                        s.remove(startMatches.start, startMatches.end);
                        s.remove(endMatches.start, endMatches.end);
                    }
                    else {
                        s.remove(startMatches.start, endMatches.end);
                    }
                    ranges.push([startMatches.start, endMatches.end]);
                    return;
                default:
                    throw new Error('Unknown if variant ' + variant + '.');
            }
        });
    }
    const type = options.type || 'auto';
    if (type === 'auto' || type === 'js') {
        preprocessByType(TYPES.js);
    }
    if (type === 'auto' || type === 'html') {
        preprocessByType(TYPES.html);
    }
    return {
        code: s.toString(),
        map: options.sourceMap ? s.generateMap(options.sourceMap) : null,
        isInPreprocessor,
    };
}
const startPattern = '[ \t]*(?://|/\\*)[ \t]*#(ifndef|ifdef)[ \t]+([^\n*]*)(?:\\*(?:\\*|/))?(?:[ \t]*\n+)?';
const endPattern = '[ \t]*(?://|/\\*)[ \t]*#endif[ \t]*(?:\\*(?:\\*|/))?(?:[ \t]*\n)?';
const startPatternHTML = '[ \t]*<!--[ \t]*#(ifndef|ifdef|if)[ \t]+(.*?)[ \t]*(?:-->|!>)(?:[ \t]*\n+)?';
const endPatternHTML = '[ \t]*<!(?:--)?[ \t]*#endif[ \t]*(?:-->|!>)(?:[ \t]*\n)?';
const TYPES = {
    js: {
        start: {
            pattern: startPattern,
            regex: new RegExp(startPattern, 'mi'),
        },
        end: {
            pattern: endPattern,
            regex: new RegExp(endPattern, 'mi'),
        },
    },
    html: {
        start: {
            pattern: startPatternHTML,
            regex: new RegExp(startPatternHTML, 'mi'),
        },
        end: {
            pattern: endPatternHTML,
            regex: new RegExp(endPatternHTML, 'mi'),
        },
    },
};
function replaceRecursive(type, source, s, processor) {
    function matchReplacePass(content, startOffset = 0) {
        const matches = xregexp.matchRecursive(content, type.start.pattern, type.end.pattern, 'gmi', {
            valueNames: ['between', 'left', 'match', 'right'],
        });
        let left = null;
        let match = null;
        let right = null;
        matches.forEach(function ({ name, value, start, end }) {
            start = start + startOffset;
            end = end + startOffset;
            switch (name) {
                case 'between':
                    break;
                case 'left':
                    left = {
                        start,
                        end,
                        value: type.start.regex.exec(value),
                    };
                    break;
                case 'match':
                    match = {
                        start,
                        end,
                        value,
                    };
                    break;
                case 'right':
                    right = {
                        start,
                        end,
                        value: type.end.regex.exec(value),
                    };
                    if (left && match && right) {
                        processor(s, left, right, match, matchReplacePass);
                        left = null;
                        match = null;
                        right = null;
                    }
                    break;
            }
        });
    }
    matchReplacePass(source);
}
function getTestTemplate(test) {
    test = test || 'true';
    test = test.trim();
    // force single equals replacement
    // 不替换，会影响 >= 等判断
    // test = test.replace(/([^=!])=([^=])/g, '$1==$2');
    test = test.replace(/-/g, '_');
    return new Function('context', 'with (context||{}){ return ( ' + test + ' ); }');
}
function testPasses(test, context) {
    var testFn = getTestTemplate(test);
    try {
        return testFn(context);
    }
    catch (e) { }
    return false;
}

exports.preprocess = preprocess;
